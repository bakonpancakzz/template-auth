package tools

import (
	"crypto/hmac"
	"crypto/md5"
	"crypto/rand"
	"crypto/sha256"
	"crypto/subtle"
	"encoding/base64"
	"encoding/binary"
	"errors"
	"fmt"
	"math/big"
	"strings"
	"time"

	"golang.org/x/crypto/bcrypt"
)

// Picks a Random Number between 0-999999 for One-Time Passcodes
func GeneratePasscode() string {
	n, _ := rand.Int(rand.Reader, big.NewInt(999999))
	return fmt.Sprintf("%06d", n)
}

// Generate Six 8-Character Recovery Codes for MFA Setup
func GenerateRecoveryCodes() []string {
	codes := make([]string, 6)
	for i := range codes {
		b := make([]byte, 4)
		rand.Read(b)
		codes[i] = fmt.Sprintf("%X", b)
	}
	return codes
}

// Generate a String with a Signature, which can be verified with CompareSignedString func
// to ensure it was generated by the server. Additionally the string is generally unique.
func GenerateSignedString() string {
	// Generate Payload
	b := make([]byte, 32)
	t := time.Now().Unix() - EPOCH_SECONDS
	rand.Read(b[binary.PutVarint(b, t):])

	// Generate Signature
	h := hmac.New(sha256.New, HTTP_KEY)
	h.Write(b)
	s := h.Sum(nil)

	return fmt.Sprintf(
		"%s.%s",
		base64.RawURLEncoding.EncodeToString(b),
		base64.RawURLEncoding.EncodeToString(s),
	)
}

// Ensure that givenString was Generated by the Server by checking it's signature
func CompareSignedString(givenString string) bool {
	s := strings.SplitN(givenString, ".", 2)
	if len(s) != 2 {
		return false
	}

	// Decode Segments
	givenPayload, err := base64.RawURLEncoding.DecodeString(s[0])
	if err != nil {
		return false
	}
	givenSignature, err := base64.RawURLEncoding.DecodeString(s[1])
	if err != nil {
		return false
	}

	// Test Signature
	h := hmac.New(sha256.New, HTTP_KEY)
	h.Write(givenPayload)
	return hmac.Equal(h.Sum(nil), givenSignature)
}

// Wrapper to Hash Password with Predefined Effort
func GeneratePasswordHash(givenPassword string) (string, error) {
	hashBytes, err := bcrypt.GenerateFromPassword(
		[]byte(givenPassword),
		PASSWORD_HASH_EFFORT,
	)
	if err != nil {
		return "", err
	}
	return string(hashBytes), nil
}

// Wrapper to Compare Password Against Given String
func ComparePasswordHash(givenHash, givenPassword string) (bool, error) {
	err := bcrypt.CompareHashAndPassword(
		[]byte(givenHash),
		[]byte(givenPassword),
	)
	if errors.Is(err, bcrypt.ErrMismatchedHashAndPassword) {
		return false, nil
	}
	if err != nil {
		return false, err
	}
	return true, nil
}

// Compare two strings in constant time to prevent leaking of sensitive info
func CompareStringConstant(a, b string) bool {
	return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
}

// Generate Standard Hash for an Image
func GenerateImageHash(image []byte) string {
	return fmt.Sprintf("%x", md5.Sum(image))
}

// Generate Plaintext and Hashed Versions of a Application Secret
func GenerateApplicationSecret() (plain string, hashed string) {
	plain = GenerateSignedString()
	hashed = fmt.Sprintf("%X", sha256.Sum256([]byte(plain)))
	return plain, hashed
}

// Validate Plaintext Application Secret against Hash
func CompareApplicationSecret(given, stored string) bool {
	hashed := fmt.Sprintf("%X", sha256.Sum256([]byte(given)))
	return CompareStringConstant(stored, hashed)
}
