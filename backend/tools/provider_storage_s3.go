package tools

import (
	"bytes"
	"context"
	"fmt"
	"html"
	"io"
	"net/http"
	"net/url"
	"sync"
	"time"
)

// NOTE: Intended for small and simple file operations :)

type storageProviderS3 struct {
	AccessKey string // Access Key ID
	SecretKey string // Access Key Secret
	Endpoint  string // S3 Endpoint
	Region    string // S3 Region
	Bucket    string // S3 Bucket
	Host      string // To be filled from Endpoint Field
}

func (e *storageProviderS3) Start(stop context.Context, await *sync.WaitGroup) error {

	// Prepare Client
	s3url, err := url.Parse(STORAGE_S3_ENDPOINT)
	if err != nil {
		return fmt.Errorf("invalid s3 endpoint url; %s", err)
	}
	e.AccessKey = STORAGE_S3_KEY_ACCESS_KEY
	e.SecretKey = STORAGE_S3_KEY_SECRET_KEY
	e.Endpoint = STORAGE_S3_ENDPOINT
	e.Region = STORAGE_S3_REGION
	e.Bucket = STORAGE_S3_BUCKET
	e.Host = s3url.Host

	// Test Client
	filename := fmt.Sprintf("_test/__%X__", time.Now())
	filedata := "Don't worry you aren't being hacked!" +
		" This file was generated by the backend on startup to ensure it has write access to the S3 Bucket." +
		" If you're seeing this most likely the process was killed during startup." +
		" You may delete me :)"

	if err := e.Put(filename, "text/plain", []byte(filedata)); err != nil {
		return fmt.Errorf("missing write access; %s", err)
	}
	if err := e.Delete(filename); err != nil {
		return fmt.Errorf("missing delete access: %s", err)
	}

	return nil
}

func (o *storageProviderS3) Put(key, contentType string, data []byte) error {

	// Generate Request
	url := fmt.Sprint("https://", o.Endpoint, "/", key)
	req, err := http.NewRequest(http.MethodPut, url, bytes.NewReader(data))
	if err != nil {
		return err
	}
	req.Header.Add("Content-Type", contentType)
	AmazonSignRequestV4(req, data, o.AccessKey, o.SecretKey, o.Host, o.Region, "s3")

	// Send Request
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer res.Body.Close()

	if res.StatusCode < 200 || res.StatusCode > 299 {
		body, _ := io.ReadAll(res.Body)
		return fmt.Errorf("put failed: %d: %s", res.StatusCode, string(body))
	}

	return nil
}

func (o *storageProviderS3) Delete(keys ...string) error {

	// Generate Body
	var buffer bytes.Buffer
	buffer.WriteString("<Delete xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\">")
	for _, k := range keys {
		fmt.Fprintf(&buffer, "<Object><Key>%s</Key></Object>", html.EscapeString(k))
	}
	buffer.WriteString("</Delete>")
	body := buffer.Bytes()

	// Generate Request
	url := fmt.Sprint("https://", o.Endpoint, "/?delete")
	req, err := http.NewRequest(http.MethodPost, url, &buffer)
	if err != nil {
		return err
	}
	AmazonSignRequestV4(req, body, o.AccessKey, o.SecretKey, o.Host, o.Region, "s3")

	// Send Request
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer res.Body.Close()

	if res.StatusCode < 200 || res.StatusCode > 299 {
		body, _ = io.ReadAll(res.Body)
		return fmt.Errorf("server responded with status %d: %s", res.StatusCode, string(body))
	}

	return nil
}
