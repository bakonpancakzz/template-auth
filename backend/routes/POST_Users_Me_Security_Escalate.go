package routes

import (
	"errors"
	"fmt"
	"net/http"
	"time"

	"github.com/bakonpancakz/template-auth/tools"

	"github.com/jackc/pgx/v5"
)

func POST_Users_Me_Security_Escalate(w http.ResponseWriter, r *http.Request) {

	session := tools.GetSession(r)
	if session.ApplicationID != tools.SESSION_NO_APPLICATION_ID {
		tools.SendClientError(w, r, tools.ERROR_OAUTH2_USERS_ONLY)
		return
	}
	var Body struct {
		Passcode string `json:"passcode" validate:"omitempty,passcode"`
	}
	if !tools.ValidateJSON(w, r, &Body) {
		return
	}
	ctx, cancel := tools.NewContext()
	defer cancel()

	// Fetch Account with MFA Fields
	var user tools.DatabaseUser
	err := tools.Database.QueryRow(ctx,
		`SELECT
			email_address, email_verified, mfa_enabled,
			mfa_secret, mfa_codes, mfa_codes_used,
			password_hash, token_passcode, token_passcode_eat
		FROM auth.users WHERE id = $1`,
		session.UserID,
	).Scan(
		&user.EmailAddress,
		&user.EmailVerified,
		&user.MFAEnabled,
		&user.MFASecret,
		&user.MFACodes,
		&user.MFACodesUsed,
		&user.PasswordHash,
		&user.TokenPasscode,
		&user.TokenPasscodeEAT,
	)
	if errors.Is(err, pgx.ErrNoRows) {
		tools.SendClientError(w, r, tools.ERROR_UNKNOWN_USER)
		return
	}
	if err != nil {
		tools.SendServerError(w, r, err)
		return
	}

	// Attempt Multi-Factor Authentication
	if user.MFAEnabled && user.MFASecret != nil {

		// Method: TOTP Verification
		// User must attempt to prove ownership by entering a code generated by
		// their authenticator app or by entering a recovery code

		if Body.Passcode == "" {
			tools.SendClientError(w, r, tools.ERROR_MFA_PASSCODE_REQUIRED)
			return
		}

		switch len(Body.Passcode) {

		// Using Recovery Code
		case tools.MFA_RECOVERY_LENGTH:
			found := false
			for i, recoveryCode := range user.MFACodes {
				if Body.Passcode == recoveryCode {
					// Code Used?
					if (user.MFACodesUsed & (1 << i)) != 0 {
						tools.SendClientError(w, r, tools.ERROR_MFA_RECOVERY_CODE_USED)
						return
					}
					// Mark Recovery Code as Used
					if _, err := tools.Database.Exec(ctx,
						"UPDATE auth.users SET mfa_codes_used = mfa_codes_used | $1 WHERE id = $2",
						(1 << i),
						session.UserID,
					); err != nil {
						tools.SendServerError(w, r, err)
						return
					}
					found = true
					break
				}
			}
			if !found {
				tools.SendClientError(w, r, tools.ERROR_MFA_RECOVERY_CODE_INCORRECT)
				return
			}

		// Using Passcode
		case tools.MFA_PASSCODE_LENGTH:
			if !tools.ValidateTOTPCode(Body.Passcode, *user.MFASecret) {
				tools.SendClientError(w, r, tools.ERROR_MFA_PASSCODE_INCORRECT)
				return
			}

		default:
			// Should be caught by validator!
			tools.SendClientError(w, r, tools.ERROR_MFA_PASSCODE_INCORRECT)
			return
		}

	} else if tools.EMAIL_PROVIDER != "none" && user.EmailVerified {

		// Method: Email Verification
		// User must attempt to prove ownership by entering a passcode sent to
		// their email address
		if Body.Passcode == "" ||
			user.TokenPasscode == nil ||
			user.TokenPasscodeEAT == nil ||
			time.Now().After(*user.TokenPasscodeEAT) {

			// The user did not provide a passcode or it has expired
			// Generate a new passcode and send to their email address

			// Set Passcode Fields
			passcode := tools.GeneratePasscode()
			passcodeExpiration := time.Now().Add(tools.LIFETIME_TOKEN_EMAIL_PASSCODE)
			if _, err = tools.Database.Exec(ctx,
				`UPDATE auth.users SET
					updated 		   = CURRENT_TIMESTAMP,
					token_passcode 	   = $1,
					token_passcode_eat = $2
				WHERE id = $3`,
				passcode,
				passcodeExpiration,
				session.UserID,
			); err != nil {
				tools.SendServerError(w, r, err)
				return
			}

			// Send Passcode to Account Owner
			go func() {
				subCtx, subCancel := tools.NewContext()
				defer subCancel()

				// Fetch Displayname
				displayname := tools.EMAIL_DEFAULT_DISPLAYNAME
				tools.Database.
					QueryRow(subCtx, "SELECT displayname FROM auth.profiles WHERE user_id = $1", user.ID).
					Scan(&displayname)

				// Send Email
				tools.TemplateLoginPasscode(
					user.EmailAddress,
					tools.LocalsLoginPasscode{
						Displayname: displayname,
						Code:        passcode,
						Lifetime:    fmt.Sprint(tools.LIFETIME_TOKEN_EMAIL_PASSCODE.Minutes()),
					},
				)
			}()

			tools.SendClientError(w, r, tools.ERROR_MFA_EMAIL_SENT)
			return

		} else {

			// User is attempting to prove ownership by entering a passcode
			if Body.Passcode != *user.TokenPasscode {
				tools.SendClientError(w, r, tools.ERROR_MFA_PASSCODE_INCORRECT)
				return
			}
		}

	} else if user.PasswordHash != nil {

		// Method: Password
		// User must attempt to prove ownership by re-entering their password
		if match, err := tools.ComparePasswordHash(*user.PasswordHash, Body.Passcode); err != nil {
			tools.SendServerError(w, r, err)
			return
		} else if !match {
			tools.SendClientError(w, r, tools.ERROR_MFA_PASSWORD_INCORRECT)
			return
		}

	} else {
		// Method: None
		// User couldn't prove ownership as all possible methods were exhausted.
		tools.SendClientError(w, r, tools.ERROR_LOGIN_PASSWORD_RESET)
		return
	}

	// Mark Current Session as Elevated
	elevatedUntil := time.Now().Add(tools.LIFETIME_TOKEN_USER_ELEVATION)
	if _, err := tools.Database.Exec(ctx,
		"UPDATE auth.sessions SET elevated_until = $1 WHERE id = $2",
		elevatedUntil,
		session.SessionID,
	); err != nil {
		tools.SendServerError(w, r, err)
		return
	}

	// Organize Session
	tools.SendJSON(w, r, http.StatusOK, map[string]any{
		"elevate_until": elevatedUntil.Unix(),
	})
}
