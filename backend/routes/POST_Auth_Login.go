package routes

import (
	"net/http"
	"time"

	"github.com/bakonpancakz/template-auth/tools"

	"github.com/jackc/pgx/v5"
)

func POST_Auth_Login(w http.ResponseWriter, r *http.Request) {

	// Parse Request Body
	var Body struct {
		Email    string `json:"email" validate:"required,email"`
		Password string `json:"password" validate:"required"`
		Passcode string `json:"passcode" validate:"omitempty,passcode"`
	}
	if !tools.ValidateJSON(w, r, &Body) {
		return
	}
	ctx, cancel := tools.NewContext()
	defer cancel()

	// Find Relevant Account
	var user tools.DatabaseUser
	err := tools.Database.QueryRow(ctx,
		`SELECT 
			id, email_address, email_verified, ip_address, mfa_enabled, 
			mfa_secret, mfa_codes, mfa_codes_used, password_hash
		FROM auth.users
		WHERE email_address = LOWER($1)`,
		Body.Email,
	).Scan(
		&user.ID,
		&user.EmailAddress,
		&user.EmailVerified,
		&user.IPAddress,
		&user.MFAEnabled,
		&user.MFASecret,
		&user.MFACodes,
		&user.MFACodesUsed,
		&user.PasswordHash,
	)
	if err == pgx.ErrNoRows {
		tools.SendClientError(w, r, tools.ERROR_LOGIN_INCORRECT)
		return
	}
	if err != nil {
		tools.SendServerError(w, r, err)
		return
	}

	// Password Validation
	if user.PasswordHash == nil {
		// Intended for a scrapped feature where passwords found in a data
		// breach on another platform would be cleared to protect the user
		tools.SendClientError(w, r, tools.ERROR_LOGIN_PASSWORD_RESET)
		return
	}
	if ok, err := tools.ComparePasswordHash(*user.PasswordHash, Body.Password); err != nil {
		tools.SendServerError(w, r, err)
		return
	} else if !ok {
		tools.SendClientError(w, r, tools.ERROR_LOGIN_INCORRECT)
		return
	}

	// Filter: Multi-Factor Authentication
	sessionAgent := r.UserAgent()
	sessionAddress := tools.GetRemoteIP(r)
	if user.MFAEnabled && user.MFASecret != nil {

		// Method: TOTP Verification
		// User must attempt to prove ownership by entering a code generated by
		// their authenticator app or by entering a recovery code

		if Body.Passcode == "" {
			tools.SendClientError(w, r, tools.ERROR_MFA_PASSCODE_REQUIRED)
			return
		}

		switch len(Body.Passcode) {

		// Use Recovery Code
		case tools.MFA_RECOVERY_LENGTH:
			found := false
			for i, recoveryCode := range user.MFACodes {
				if Body.Passcode == recoveryCode {
					// Code Used?
					if (user.MFACodesUsed & (1 << i)) != 0 {
						tools.SendClientError(w, r, tools.ERROR_MFA_RECOVERY_CODE_USED)
						return
					}
					// Mark Recovery Code as Used
					if _, err := tools.Database.Exec(ctx,
						"UPDATE auth.users SET mfa_codes_used = $1 WHERE id = $2",
						user.MFACodesUsed|(1<<i),
						user.ID,
					); err != nil {
						tools.SendServerError(w, r, err)
						return
					}
					found = true
					break
				}
			}
			if !found {
				tools.SendClientError(w, r, tools.ERROR_MFA_RECOVERY_CODE_INCORRECT)
				return
			}

		// Using Passcode
		case tools.MFA_PASSCODE_LENGTH:
			if !tools.ValidateTOTPCode(Body.Passcode, *user.MFASecret) {
				tools.SendClientError(w, r, tools.ERROR_MFA_PASSCODE_INCORRECT)
				return
			}

		default:
			// Should be caught by validator!
			tools.SendClientError(w, r, tools.ERROR_MFA_PASSCODE_INCORRECT)
			return
		}

	} else if tools.EMAIL_PROVIDER != "none" && user.EmailVerified &&
		!tools.CompareStringConstant(user.IPAddress, sessionAddress) {

		// Method: Allow Login
		// User must allow this unknown new location access to their account by
		// clicking on a button sent to their email address

		// Generate New Token
		loginToken := tools.GenerateSignedString()
		tag, err := tools.Database.Exec(ctx,
			`UPDATE auth.users SET
				updated = CURRENT_TIMESTAMP,
				token_login 		= $1,
				token_login_data 	= $2,
				token_login_eat 	= $3
			WHERE id = $4`,
			loginToken,
			sessionAddress,
			time.Now().Add(tools.LIFETIME_TOKEN_EMAIL_LOGIN),
		)
		if err != nil {
			tools.SendServerError(w, r, err)
			return
		}
		if tag.RowsAffected() == 0 {
			tools.SendClientError(w, r, tools.ERROR_UNKNOWN_USER)
			return
		}

		// Alert Account Owner
		go func() {
			subCtx, subCancel := tools.NewContext()
			defer subCancel()

			// Fetch Displayname
			displayname := tools.EMAIL_DEFAULT_DISPLAYNAME
			tools.Database.
				QueryRow(subCtx, "SELECT displayname FROM auth.profiles WHERE user_id = $1", user.ID).
				Scan(&displayname)

			// Send Email
			tools.TemplateLoginNewLocation(
				user.EmailAddress,
				tools.LocalsLoginNewLocation{
					Displayname:    displayname,
					Token:          loginToken,
					IpAddress:      sessionAddress,
					Timestamp:      tools.LookupTimezone(time.Now(), sessionAddress),
					DeviceBrowser:  tools.LookupBrowser(sessionAgent),
					DeviceLocation: tools.LookupLocation(sessionAddress),
				},
			)
		}()

		tools.SendClientError(w, r, tools.ERROR_MFA_EMAIL_SENT)
		return
	}

	// Update Account
	sessionCreated := time.Now()
	sessionToken := tools.GenerateSignedString()
	tag, err := tools.Database.Exec(ctx,
		`UPDATE auth.users SET
			updated    = CURRENT_TIMESTAMP,
			ip_address = $1
		WHERE id = $2`,
		sessionAddress,
		user.ID,
	)
	if err != nil {
		tools.SendServerError(w, r, err)
		return
	}
	if tag.RowsAffected() == 0 {
		tools.SendClientError(w, r, tools.ERROR_UNKNOWN_USER)
		return
	}

	// Create New Session
	_, err = tools.Database.Exec(ctx,
		`INSERT INTO auth.sessions 
			(created, user_id, token, device_ip_address, device_user_agent) 
		VALUES ($1, $2, $3, $4, $5);`,
		sessionCreated,
		user.ID,
		sessionToken,
		sessionAddress,
		sessionAgent,
	)
	if err != nil {
		tools.SendServerError(w, r, err)
		return
	}

	// Alert Account Owner
	go func() {
		subCtx, subCancel := tools.NewContext()
		defer subCancel()

		// Fetch Displayname
		displayname := tools.EMAIL_DEFAULT_DISPLAYNAME
		tools.Database.
			QueryRow(subCtx, "SELECT displayname FROM auth.profiles WHERE user_id = $1", user.ID).
			Scan(&displayname)

		// Send Email
		tools.TemplateLoginNewDevice(
			user.EmailAddress,
			tools.LocalsLoginNewDevice{
				Displayname:    displayname,
				IpAddress:      sessionAddress,
				Timestamp:      tools.LookupTimezone(time.Now(), sessionAddress),
				DeviceBrowser:  tools.LookupBrowser(sessionAgent),
				DeviceLocation: tools.LookupLocation(sessionAddress),
			},
		)
	}()

	// Set Session
	http.SetCookie(w, &http.Cookie{
		Name:     tools.HTTP_COOKIE_NAME,
		Value:    sessionToken,
		Path:     "",
		Domain:   tools.HTTP_COOKIE_DOMAIN,
		MaxAge:   int(tools.LIFETIME_TOKEN_USER_COOKIE),
		Secure:   tools.PRODUCTION,
		HttpOnly: true,
		SameSite: http.SameSiteLaxMode,
	})
	w.WriteHeader(http.StatusNoContent)
}
